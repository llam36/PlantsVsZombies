#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
#include "images/zombie.h"
#include "images/plant.h"
#include "images/garden.h"
#include "images/startScreen.h"

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START,
  WAIT,
  PREPLAY,
  PLAY,
  WIN,
  LOSE,
};

int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;
  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;
  // drawImageDMA(23,33,PLANT_WIDTH,PLANT_HEIGHT,plant);
  // Load initial application state
  enum gba_state state = START;
  struct plant *pp, *opp;
  struct zombie *zp, *ozp;
  struct bullet *bp, *obp;
  struct gameState cs, ps;
  char message[51];
  int health;
  char score[51];

  while (1) {
    ps = cs;
    currentButtons = BUTTONS; // Load the current state of the buttons
    switch (state)
    {
    case START:
      break;
    case WAIT:
      break;
    case PREPLAY:
    //init plant
    for (int i = 0; i < MAXPLANT; i++) {
      pp = &cs.plant[i];
      pp->row = 30 * (i+1);
      pp->col = 30 * (i+1);
      pp->rd = 1;
      // init bullets
      bp = &cs.bullets[i];
      bp->row = pp->row + 3;
      bp->col = pp->col + PLANT_WIDTH;
      bp->cd = 2;
      bp->color = GRAY;
    }
    //init zombie
      zp = &cs.zombie;
      zp -> row = 12;
      zp -> col = 210;
      zp -> rd = 5;
      zp -> cd = 5;
      health = 10;
      break;
    case PLAY:
      for (int i = 0; i < MAXPLANT; i++)
      {
        // move plant
        pp = &cs.plant[i];
        pp->row += pp->rd;
        if (pp->row <= 25)
        {
          pp->row = 25;
          pp->rd = -pp->rd;
        }
        if (pp->row >= HEIGHT - PLANT_HEIGHT - 5)
        {
          pp->row = HEIGHT - PLANT_HEIGHT - 5;
          pp->rd = -pp->rd;
        }
        removeBG(pp->row, pp->col, PLANT_WIDTH, PLANT_HEIGHT, plant, garden, plantNoBG[i]);
        // move bullets
        bp = &cs.bullets[i];
        bp->col += bp->cd;
        if (bp->col >= WIDTH)
        {
          bp->col = pp->col + PLANT_WIDTH;
          bp->row = pp->row + 3;
        }
        if ((zp->col <= (bp->col) && ((bp->row >= zp->row && bp->row <= zp->row + ZOMBIE_HEIGHT) || (bp->row + 2 >= zp->row && bp->row + 2 <= zp->row + ZOMBIE_HEIGHT))))
        {
          health -= 1;
          bp->col = pp->col + PLANT_WIDTH;
          bp->row = pp->row + 3;
        }
        if (health <= 0)
        {
          health = 0;
          state = LOSE;
        }
        // collision handling
        if ((zp->col + 10 <= (pp->col + PLANT_WIDTH) && ((pp->row >= zp->row && pp->row <= zp->row + ZOMBIE_HEIGHT) || (pp->row + PLANT_HEIGHT >= zp->row && pp->row + PLANT_HEIGHT <= zp->row + ZOMBIE_HEIGHT))))
        {
          health = 0;
          state = LOSE;
        }
      }  
        // move zombie
        zp = &cs.zombie;
        if (KEY_JUST_PRESSED(BUTTON_LEFT, currentButtons, previousButtons))
        {
          zp->col -= zp->cd;
          if (zp->col <= 10)
          {
            state = WIN;
          }
        }
        if (KEY_JUST_PRESSED(BUTTON_RIGHT, currentButtons, previousButtons))
        {
          zp->col += zp->cd;
          if (zp->col >= WIDTH - ZOMBIE_WIDTH - 10)
          {
            zp->col = WIDTH - ZOMBIE_WIDTH - 10;
          }
        }
        if (KEY_JUST_PRESSED(BUTTON_DOWN, currentButtons, previousButtons))
        {
          zp->row += zp->rd;
          if (zp->row >= HEIGHT - ZOMBIE_HEIGHT - 5)
          {
            zp->row = HEIGHT - ZOMBIE_HEIGHT - 5;
          }
        }
        if (KEY_JUST_PRESSED(BUTTON_UP, currentButtons, previousButtons))
        {
          zp->row -= zp->rd;
          if (zp->row <= 10)
          {
            zp->row = 10;
          }
        }
        removeBG(zp->row, zp->col, ZOMBIE_WIDTH, ZOMBIE_HEIGHT, zombie, garden, zombieNoBG);
        break;
      case WIN:
        sprintf(score, "Health: %d", health);
        sprintf(message, "BRAINZZ");
        break;
      case LOSE:
        sprintf(score, "Health: %d", health);
        sprintf(message, "YOU LOST");
        break;
      }
    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw
    waitForVBlank();
    switch (state) {
      case START:
        drawFullScreenImageDMA(startScreen);
        state = WAIT;
        break;
      case WAIT: {
        char disp[51];
        sprintf(disp, "Press START to play...");
        drawRectDMA(140, 50, 150, 10, GRAY);
        drawCenteredString(140, 50, 150, 10, disp, WHITE);
        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
          state = PREPLAY;
        }
        break;
      }
      case PREPLAY:
        drawFullScreenImageDMA(garden);
        state = PLAY;
        break;
      case PLAY:
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons))
        {
          state = START;
        }
        for (int i = 0; i < MAXPLANT; i++)
        {
          opp = &ps.plant[i];
          undrawImageDMA(opp->row, opp->col, PLANT_WIDTH, PLANT_HEIGHT, garden);
        }
        for (int i = 0; i < MAXPLANT; i++) {
          obp = &ps.bullets[i];
          undrawImageDMA(obp->row, obp->col, 4, 4, garden);
        }
        for (int i = 0; i < MAXPLANT; i++)
        {
          bp = &cs.bullets[i];
          drawRectDMA(bp->row, bp->col, 4, 4, bp->color);
        }
        for (int i = 0; i < MAXPLANT; i++)
        {
          pp = &cs.plant[i];
          drawImageDMA(pp->row, pp->col, PLANT_WIDTH, PLANT_HEIGHT, plantNoBG[i]);
        }
        ozp = &ps.zombie;
        undrawImageDMA(ozp->row, ozp->col, ZOMBIE_WIDTH, ZOMBIE_HEIGHT, garden);
        zp = &cs.zombie;
        drawImageDMA(zp->row, zp->col, ZOMBIE_WIDTH, ZOMBIE_HEIGHT, zombieNoBG);
        sprintf(score, "Health: %d", health);
        drawRectDMA(147, 165, 60, 10, GRAY);
        drawCenteredString(147, 165, 60, 10, score, WHITE);
        break;
      case WIN:;
        drawRectDMA(147, 165, 60, 10, GRAY);
        drawCenteredString(147, 165, 60, 10, score, WHITE);
        drawRectDMA(70, 90, 80, 10, GRAY);
        drawCenteredString(70, 90, 80, 10, message, WHITE);
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons))
        {
          state = START;
        }
        break;
      case LOSE:;
        drawRectDMA(147, 165, 60, 10, GRAY);
        drawCenteredString(147, 165, 60, 10, score, WHITE);
        drawRectDMA(70, 90, 80, 10, GRAY);
        drawCenteredString(70, 90, 80, 10, message, WHITE);
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons))
        {
          state = START;
        }
        break;
      }

    previousButtons = currentButtons; // Store the current state of the buttons
  }

  UNUSED(previousButtons); // You can remove this once previousButtons is used
  UNUSED(bp);
  UNUSED(obp);
  return 0;
}
